<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Overtime - Lowpoly FPS Horror</title>
    <style>
      body { margin: 0; overflow: hidden; background: #000; }
      #startScreen {
        position: absolute; top:0; left:0; width:100%; height:100%;
        background:black; display:flex; align-items:center; justify-content:center;
        flex-direction:column; color:white; font-family:sans-serif; z-index:10;
      }
      #startButton { padding: 15px 30px; font-size: 20px; cursor: pointer; }
    </style>
  </head>
  <body>
    <div id="startScreen">
      <h1>Overtime</h1>
      <button id="startButton">Schicht starten</button>
    </div>

    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js";
      import { PointerLockControls } from "https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/controls/PointerLockControls.js";

      let camera, scene, renderer, controls;
      const objects = []; // für Kollision
      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();
      const moveForward = { state: false };
      const moveBackward = { state: false };
      const moveLeft = { state: false };
      const moveRight = { state: false };
      const clock = new THREE.Clock();

      const startButton = document.getElementById("startButton");
      const startScreen = document.getElementById("startScreen");

      startButton.addEventListener("click", () => {
        startScreen.style.display = "none";
        init();
      });

      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 8);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        controls = new PointerLockControls(camera, document.body);
        document.body.addEventListener("click", () => {
          controls.lock();
        });

        // Licht (Deckenlampen)
        const light = new THREE.AmbientLight(0x404060, 0.8);
        scene.add(light);
        for (let i = 0; i < 5; i++) {
          const spot = new THREE.PointLight(0x99bbff, 0.6, 20);
          spot.position.set(-15 + i * 7, 5, 0);
          scene.add(spot);
        }

        // Boden
        const floorGeometry = new THREE.PlaneGeometry(50, 50);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x222831 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Wände (einfacher Raum)
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x2e3440 });
        const wallGeometry = new THREE.BoxGeometry(50, 6, 0.5);

        const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
        backWall.position.set(0, 3, -25);
        scene.add(backWall);
        objects.push(backWall);

        const frontWall = new THREE.Mesh(wallGeometry, wallMaterial);
        frontWall.position.set(0, 3, 25);
        scene.add(frontWall);
        objects.push(frontWall);

        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, 6, 50), wallMaterial);
        leftWall.position.set(-25, 3, 0);
        scene.add(leftWall);
        objects.push(leftWall);

        const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, 6, 50), wallMaterial);
        rightWall.position.set(25, 3, 0);
        scene.add(rightWall);
        objects.push(rightWall);

        // Büro-Tische mit PCs
        const tableMaterial = new THREE.MeshStandardMaterial({ color: 0x3b4252 });
        const pcMaterial = new THREE.MeshStandardMaterial({ color: 0x5e81ac });

        for (let i = -3; i < 3; i++) {
          for (let j = -2; j < 3; j++) {
            const table = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 1), tableMaterial);
            table.position.set(i * 4, 1, j * 4);
            scene.add(table);
            objects.push(table);

            // PC-Monitor
            const monitor = new THREE.Mesh(new THREE.BoxGeometry(1, 0.7, 0.1), pcMaterial);
            monitor.position.set(i * 4, 1.6, j * 4 - 0.3);
            scene.add(monitor);
            objects.push(monitor);

            // PC-Tower
            const tower = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.7, 0.6), pcMaterial);
            tower.position.set(i * 4 + 0.8, 1.35, j * 4);
            scene.add(tower);
            objects.push(tower);
          }
        }

        // Movement Controls
        const onKeyDown = function (event) {
          switch (event.code) {
            case "ArrowUp":
            case "KeyW": moveForward.state = true; break;
            case "ArrowLeft":
            case "KeyA": moveLeft.state = true; break;
            case "ArrowDown":
            case "KeyS": moveBackward.state = true; break;
            case "ArrowRight":
            case "KeyD": moveRight.state = true; break;
          }
        };
        const onKeyUp = function (event) {
          switch (event.code) {
            case "ArrowUp":
            case "KeyW": moveForward.state = false; break;
            case "ArrowLeft":
            case "KeyA": moveLeft.state = false; break;
            case "ArrowDown":
            case "KeyS": moveBackward.state = false; break;
            case "ArrowRight":
            case "KeyD": moveRight.state = false; break;
          }
        };
        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);

        animate();
      }

      function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();

        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;

        direction.z = Number(moveForward.state) - Number(moveBackward.state);
        direction.x = Number(moveRight.state) - Number(moveLeft.state);
        direction.normalize();

        if (moveForward.state || moveBackward.state) velocity.z -= direction.z * 400.0 * delta;
        if (moveLeft.state || moveRight.state) velocity.x -= direction.x * 400.0 * delta;

        controls.moveRight(- velocity.x * delta);
        controls.moveForward(- velocity.z * delta);

        // einfache Kollision
        const camPos = controls.getObject().position;
        for (let obj of objects) {
          const box = new THREE.Box3().setFromObject(obj);
          if (box.containsPoint(camPos)) {
            // zurückstoßen
            camPos.x -= velocity.x * delta * 2;
            camPos.z -= velocity.z * delta * 2;
          }
        }

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
