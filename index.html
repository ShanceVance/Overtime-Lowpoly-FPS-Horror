<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Überstunden – Lowpoly FPS Horror</title>
  <style>
    :root { --fg:#eaeaf2; --bg:#000; }
    html,body { margin:0; height:100%; background:var(--bg); color:var(--fg); font-family:Inter,system-ui,Segoe UI,Arial,sans-serif; overflow:hidden; }
    #overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:radial-gradient(1000px 600px at 50% 50%, rgba(0,0,0,.35), rgba(0,0,0,.92)); z-index:5; }
    .panel { max-width:720px; padding:24px; border-radius:14px; background:rgba(15,15,20,.6); border:1px solid rgba(255,255,255,.12); backdrop-filter:blur(6px); }
    .panel h1 { margin:0 0 10px; font-size:26px; }
    .btn { display:inline-block; margin-top:10px; padding:12px 18px; border-radius:10px; background:#0d6efd; color:#fff; border:none; cursor:pointer; font-weight:600; }
    #crosshair { position:fixed; inset:0; pointer-events:none; display:none; }
    #crosshair::after { content:""; position:absolute; top:50%; left:50%; width:12px; height:12px; margin:-6px 0 0 -6px; border-radius:50%; border:2px solid rgba(255,255,255,.5); }
    #hint { position:fixed; bottom:24px; left:50%; transform:translateX(-50%); padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,.12); background:rgba(15,15,20,.6); display:none; white-space:nowrap; }
  </style>
</head>
<body>
  <div id="overlay">
    <div class="panel">
      <h1>Überstunden – Nachtschicht</h1>
      <p>WASD bewegen · Shift rennen · Maus zum Umschauen · Klick sperrt Maus · <b>E</b> interagieren (Türen).</p>
      <button id="startBtn" class="btn">Schicht starten</button>
      <div style="opacity:.75; font-size:12px; margin-top:8px;">HTML5/WebGL – läuft direkt über GitHub Pages.</div>
    </div>
  </div>
  <div id="crosshair"></div>
  <div id="hint">E – Tür öffnen</div>

  <!-- Import Map: erlaubt `import "three"` im Browser -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.150.1/build/three.module.js"
    }
  }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { PointerLockControls } from "https://unpkg.com/three@0.150.1/examples/jsm/controls/PointerLockControls.js";

    // DOM
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');
    const crosshair = document.getElementById('crosshair');
    const hint = document.getElementById('hint');

    // Globals
    let scene, camera, renderer, controls;
    const clock = new THREE.Clock();
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const keys = { w:false, a:false, s:false, d:false, shift:false, e:false };

    // Collision
    const colliders = [];    // THREE.Box3 list (blocking)
    const interactables = []; // meshes with userData {type:'door', ref:...}

    // Helpers
    function addColliderFromMesh(mesh){
      mesh.updateMatrixWorld(true);
      const box = new THREE.Box3().setFromObject(mesh);
      colliders.push(box);
      return box;
    }
    function refreshColliderForMesh(box, mesh){
      mesh.updateMatrixWorld(true);
      box.setFromObject(mesh);
    }
    function collidesAt(pos, radius=0.35){
      for(const b of colliders){
        if(pos.x > b.min.x - radius && pos.x < b.max.x + radius &&
           pos.y > b.min.y - 1.0   && pos.y < b.max.y + 1.0 &&
           pos.z > b.min.z - radius && pos.z < b.max.z + radius){
          return true;
        }
      }
      return false;
    }

    // Materials
    const matFloor = new THREE.MeshStandardMaterial({ color:0x1b1c1f, roughness:1 });
    const matWall  = new THREE.MeshStandardMaterial({ color:0x2a2d34, roughness:.95 });
    const matPartition = new THREE.MeshStandardMaterial({ color:0x3a3e46, roughness:.95 });
    const matDesk  = new THREE.MeshStandardMaterial({ color:0x202225, roughness:.9 });
    const matPC    = new THREE.MeshStandardMaterial({ color:0x101010, roughness:.6 });
    const matCRT   = new THREE.MeshStandardMaterial({ color:0x0e1a24, roughness:.7, emissive:0x071017, emissiveIntensity:.2 });
    const matWindow= new THREE.MeshStandardMaterial({ color:0x00111c, roughness:.2, metalness:.4, emissive:0x0a1f33, emissiveIntensity:.3 });
    const matDoor  = new THREE.MeshStandardMaterial({ color:0x080808, roughness:.7 });

    // Geometry factory
    function box(x,y,z, sx,sy,sz, mat){
      const m = new THREE.Mesh(new THREE.BoxGeometry(sx,sy,sz), mat);
      m.position.set(x,y,z);
      scene.add(m);
      return m;
    }

    // Door (hinged)
    function createDoor(x, z, width=1.0, height=2.1, thickness=0.08, openLeft=true){
      const pivot = new THREE.Object3D();
      pivot.position.set(x, 0, z);
      scene.add(pivot);

      const door = new THREE.Mesh(new THREE.BoxGeometry(thickness,height,width), matDoor);
      door.position.y = height/2;
      // Hinge at one side
      door.position.x = openLeft ? 0 : 0;
      door.rotation.y = 0;
      pivot.add(door);

      const entry = { pivot, door, open:false, collider: addColliderFromMesh(door) };
      door.userData = { type:'door', ref: entry };
      interactables.push(door);
      return entry;
    }
    function toggleDoor(entry){
      entry.open = !entry.open;
      // simple 90° swing
      entry.pivot.rotation.y = entry.open ? -Math.PI/2 : 0;
      // update / enable-disable collider
      if(entry.open){
        const idx = colliders.indexOf(entry.collider);
        if(idx>=0) colliders.splice(idx,1);
      } else {
        // re-add collider
        if(!colliders.includes(entry.collider)) colliders.push(entry.collider);
        refreshColliderForMesh(entry.collider, entry.door);
      }
    }

    // Raycast for interaction hint
    const raycaster = new THREE.Raycaster();
    function updateHint(){
      if(!controls || !controls.isLocked){ hint.style.display = 'none'; requestAnimationFrame(updateHint); return; }
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
      const hits = raycaster.intersectObjects(interactables, false);
      if(hits.length && hits[0].distance < 2.0){
        hint.style.display = 'block';
      } else {
        hint.style.display = 'none';
      }
      requestAnimationFrame(updateHint);
    }

    // Build level
    function buildLevel(){
      // Floor (big)
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(80, 60), matFloor);
      floor.rotation.x = -Math.PI/2; floor.position.set(0,0,0); floor.receiveShadow = true; scene.add(floor);

      // Office room bounds (perimeter walls)
      // Office area ~ (-18..18 in X), (-20..10 in Z)
      const wallThickness = 0.3, wallHeight=3;
      // North (vorn)
      addColliderFromMesh( box(0, wallHeight/2, 10, 36, wallHeight, wallThickness, matWall) );
      // South (hinten)
      addColliderFromMesh( box(0, wallHeight/2, -20, 36, wallHeight, wallThickness, matWall) );
      // West (links) – mit Fenstersegmenten (keine Lücken für Kollision, nur Optik)
      addColliderFromMesh( box(-18, wallHeight/2, -5, wallThickness, wallHeight, 30, matWall) );
      for(let i=0;i<6;i++){
        const win = box(-17.85, 1.5, -18 + i*6, 0.08, 1.2, 2.0, matWindow);
      }
      // East (rechts) – Wand mit zwei Türen (Küche/Flur) -> Kollision bleibt, wir schneiden optisch Öffnungen (separat platziert)
      addColliderFromMesh( box(18, wallHeight/2, -5, wallThickness, wallHeight, 30, matWall) );

      // Eingänge rechts (Öffnungen ohne Kollision: wir bauen NICHT-kollidierende Rahmen)
      // Küche (vorne rechts)
      box(18, 1.1, 6, 0.1, 2.2, 1.2, matWall); // Türrahmen (optisch)
      // Flur (mittig rechts)
      box(18, 1.1, -2, 0.1, 2.2, 1.6, matWall);

      // Küche (kleiner Raum rechts vorne)
      // Raumgröße: (x: 22..30, z: 4..10)
      addColliderFromMesh( box(26, wallHeight/2, 10, 8, wallHeight, wallThickness, matWall) ); // Nord
      addColliderFromMesh( box(22, wallHeight/2, 7, wallThickness, wallHeight, 6, matWall) ); // West (mit Türöffnung am Office, wir lassen kleinen Spalt in der Office-Wand als "Durchgang")
      addColliderFromMesh( box(30, wallHeight/2, 7, wallThickness, wallHeight, 6, matWall) ); // Ost
      addColliderFromMesh( box(26, wallHeight/2, 4, 8, wallHeight, wallThickness, matWall) ); // Süd

      // Flur (lang rechts, nach hinten)
      // Korridor entlang X=26, Z: -2 bis -30
      addColliderFromMesh( box(22, wallHeight/2, -16, wallThickness, wallHeight, 28, matWall) ); // West
      addColliderFromMesh( box(30, wallHeight/2, -16, wallThickness, wallHeight, 28, matWall) ); // Ost
      addColliderFromMesh( box(26, wallHeight/2, -30, 8, wallHeight, wallThickness, matWall) ); // Süd Ende
      // Fake-Türen am Flur (optisch, nicht interaktiv)
      for(let i=0;i<6;i++){
        const z = -4 - i*4;
        box(22.05, 1.05, z, 0.02, 2.1, 1.0, matDoor); // linke Reihe
        box(29.95, 1.05, z-2, 0.02, 2.1, 1.0, matDoor); // rechte versetzt
      }

      // Toilette am Flurende (interaktive Tür in der Südwand)
      const toiletDoor = createDoor(26, -30 + 0.01, 1.0, 2.1, 0.08, true); // sitzt direkt in Südwand des Flurs
      // Toiletten-Raum innen (hinter der Tür, z: -34..-30)
      addColliderFromMesh( box(26, wallHeight/2, -34, 8, wallHeight, wallThickness, matWall) ); // Süd
      addColliderFromMesh( box(22, wallHeight/2, -32, wallThickness, wallHeight, 4, matWall) ); // West
      addColliderFromMesh( box(30, wallHeight/2, -32, wallThickness, wallHeight, 4, matWall) ); // Ost
      // Simple „Toilette“ (Optik)
      box(25.2, 0.4, -33.0, 0.5, 0.8, 0.7, matWall);

      // Großraumbüro: Cubicles + Desks + alte PCs
      // Grid: 6 Spalten (x), 6 Reihen (z) -> ~36 Tische
      const startX = -15, startZ = 8;
      const dx = 6.0, dz = 6.0;
      for(let ix=0; ix<6; ix++){
        for(let iz=0; iz<6; iz++){
          const cx = startX + ix*dx;
          const cz = startZ - iz*dz;
          // halbhohe Trennwände (U-Form)
          const h = 1.4, t = 0.1, w = 2.2, d = 1.4;
          box(cx, h/2, cz - d/2, w, h, t, matPartition); // hinten
          box(cx - w/2, h/2, cz, t, h, d, matPartition); // links
          box(cx + w/2, h/2, cz, t, h, d, matPartition); // rechts

          // Tischplatte
          box(cx, 0.75, cz, 2.0, 0.1, 1.0, matDesk);
          // PC-Tower
          box(cx-0.8, 0.5, cz+0.3, 0.25, 0.5, 0.35, matPC);
          // CRT-Monitor
          box(cx, 1.0, cz-0.2, 0.5, 0.4, 0.45, matCRT);
          // Tastatur (flach)
          box(cx+0.2, 0.82, cz+0.1, 0.4, 0.04, 0.2, matDesk);
        }
      }

      // "Dein Schreibtisch" hinten links (ganz in der Ecke) – leicht anders platziert
      const myX = -16.5, myZ = -18.0;
      box(myX, 1.4/2, myZ - 1.4/2, 2.6, 1.4, 0.12, matPartition); // extra lange Rückwand (optisch)
      box(myX, 0.75, myZ, 2.2, 0.1, 1.1, matDesk);
      box(myX-0.9, 0.5, myZ+0.3, 0.28, 0.55, 0.38, matPC);
      box(myX, 1.0, myZ-0.2, 0.55, 0.42, 0.48, matCRT);
      box(myX+0.2, 0.82, myZ+0.1, 0.45, 0.04, 0.22, matDesk);

      // Kollisionen für Cubicles: Wir lassen die Trennwände blocken
      // (oben bereits jede Trennwand als echte Meshes in Szene -> wir könnten auch hier colliders pushen,
      //  aber das wäre sehr viel; die Office-Außenwände blocken bereits. Wenn du möchtest, aktivieren wir
      //  Kollisionen auch für Trennwände – sag Bescheid.)
    }

    // Input
    addEventListener('keydown', (e)=>{
      if(e.code==='KeyW') keys.w=true;
      if(e.code==='KeyA') keys.a=true;
      if(e.code==='KeyS') keys.s=true;
      if(e.code==='KeyD') keys.d=true;
      if(e.code==='ShiftLeft'||e.code==='ShiftRight') keys.shift=true;
      if(e.code==='KeyE') keys.e=true;
    });
    addEventListener('keyup', (e)=>{
      if(e.code==='KeyW') keys.w=false;
      if(e.code==='KeyA') keys.a=false;
      if(e.code==='KeyS') keys.s=false;
      if(e.code==='KeyD') keys.d=false;
      if(e.code==='ShiftLeft'||e.code==='ShiftRight') keys.shift=false;
      if(e.code==='KeyE') keys.e=false;
    });

    // Interaction
    function tryInteract(){
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
      const hits = raycaster.intersectObjects(interactables, false);
      if(hits.length && hits[0].distance < 2.0){
        const ud = hits[0].object.userData || {};
        if(ud.type==='door'){ toggleDoor(ud.ref); }
      }
    }

    // Init
    function init(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 500);
      camera.position.set(-10, 1.7, 8); // starte im Büro vorne links

      renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // Lights
      scene.add(new THREE.HemisphereLight(0xccccff, 0x080820, 0.6));
      const dir = new THREE.DirectionalLight(0xffffff, 0.6);
      dir.position.set(5,10,7); scene.add(dir);

      // Build
      buildLevel();

      // Controls
      controls = new PointerLockControls(camera, renderer.domElement);
      scene.add(controls.getObject());
      controls.addEventListener('lock', ()=>{ crosshair.style.display='block'; });
      controls.addEventListener('unlock', ()=>{ crosshair.style.display='none'; });

      renderer.domElement.addEventListener('pointerdown', ()=>{
        if(!controls.isLocked) controls.lock();
      });

      // Resize
      addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });

      // Start hint loop
      updateHint();
    }

    // Movement + simple collision (revert if colliding)
    function stepMovement(delta){
      // Dämpfung
      velocity.x -= velocity.x * 10 * delta;
      velocity.z -= velocity.z * 10 * delta;

      // Richtung
      direction.z = (keys.w?1:0) - (keys.s?1:0);
      direction.x = (keys.d?1:0) - (keys.a?1:0);
      if(direction.lengthSq()>0) direction.normalize();

      // Geschwindigkeit
      const speed = keys.shift ? 7.0 : 4.0;
      velocity.z -= direction.z * speed * 10 * delta;
      velocity.x -= direction.x * speed * 10 * delta;

      if(controls && controls.isLocked){
        const obj = controls.getObject();
        const before = obj.position.clone();

        controls.moveForward(-velocity.z * delta);
        controls.moveRight(-velocity.x * delta);

        const after = obj.position.clone();
        // Kollisionstest: wenn an Zielposition Kollision -> revert
        if(collidesAt(after, 0.35)){
          obj.position.copy(before);
        }
        // Fix Höhe
        obj.position.y = 1.7;
      }
    }

    // Animate
    function animate(){
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      stepMovement(delta);

      // Interact on E (single press)
      if(keys.e){
        tryInteract();
        keys.e = false;
      }

      renderer.render(scene, camera);
    }

    // Start
    startBtn.addEventListener('click', ()=>{
      overlay.style.display='none';
      init();
      animate();
    });
  </script>
</body>
</html>
